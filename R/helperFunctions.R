#' Simplify special characters in text for easier comparisons
#'
#' @param text
#'
#' @importFrom stringi stri_trans_nfd
#' @importFrom stringr str_replace_all
#'
#' @return simplified text
#' @export
#'
simpleText <- function(text) {
  str_replace_all(stri_trans_nfd(tolower(text)), "\\p{Mn}", "") |> str_trim()
}

#' Timestamp
#'
#' @returns Time formatted as %Y-%m-%d %H:%M:%S
timeStamp <- function() {
  format(Sys.time(), format = "%Y-%m-%d %H:%M:%S")
}

#' Check whether to use black or white text on a colour backgound
#'
#' @param colours A vector of colours
#'
#' @return A vector of "black" or "white" for each colour
#' @export
textBW <- function(colours) {
  colours <- col2rgb(colours)

  # Calculate the luminance (0 - 255)
  lum <- apply(colours, 2, function(x) {
    0.2126 * x[1] + 0.7152 * x[2] + 0.0722 * x[3]
  })

  return(ifelse(lum > 127.5, "black", "white"))
}

#' Make a hexadecimal colour lighter (go towards white)
#'
#' @param hex A hexadecimal colour value
#' @param factor How much whiter to make the colour. 0 = no change, 1 = white
#'
#' @return A vector of "black" or "white" for each colour
lightenColour <- function(hex, factor) {
  # Convert hex to RGB
  rgb <- col2rgb(hex) / 255

  # Move each RGB component toward white (1.0)
  lighter_rgb <- rgb + (1 - rgb) * factor

  # Convert back to hex
  rgb_to_hex <- function(x) rgb(x[1], x[2], x[3])
  rgb_to_hex(lighter_rgb)
}

#' Filter publicationDetails object based on author of interest affiliation match
#'
#' This function is useful in case there are a lot of suprious matches that
#' would be too tedious to manage one by one
#'
#' @param publicationDetails Object generated by ncbi_publicationDetails
#' @param regex Search term (regular expression) to filter affiliations
#'
#' @import dplyr stringr
#'
#' @return Filtered publicationDetails object
#'
#' @export
filter_affiliation <- function(publicationDetails, regex, includeMissing = F) {
  if (is.na(regex) || str_trim(regex) == "") {
    return(publicationDetails)
  }

  # Get PMIDs that have an affilitation match using the regex for author of interest
  toKeep <- publicationDetails$affiliations |>
    filter(str_detect(affiliation, regex)) |>
    left_join(
      publicationDetails$coAuthors |>
        filter(
          lastName %in% publicationDetails$author$lastName,
          firstName %in% publicationDetails$author$firstName,
        ) |>
        select(PMID, authorOrder, tempId),
      by = c("PMID", "authorOrder")
    ) |>
    filter(!is.na(tempId)) |>
    pull(PMID) |>
    unique()

  if (includeMissing) {
    noAffiliations <- setdiff(
      publicationDetails$articles$PMID,
      publicationDetails$affiliations$PMID |> unique()
    )
    toKeep <- c(toKeep, noAffiliations)
  }

  # Filter based on PMIDs retained
  publicationDetails$articles = publicationDetails$articles |>
    filter(PMID %in% toKeep)
  publicationDetails$coAuthors = publicationDetails$coAuthors |>
    filter(PMID %in% toKeep)
  publicationDetails$affiliations = publicationDetails$affiliations |>
    filter(PMID %in% toKeep)
  publicationDetails$meshDescriptors = publicationDetails$meshDescriptors |>
    filter(PMID %in% toKeep)
  publicationDetails$meshQualifiers = publicationDetails$meshQualifiers |>
    filter(PMID %in% toKeep)

  # Only keep author name variations that are in any of the retained articles
  publicationDetails$author = publicationDetails$author |>
    inner_join(
      publicationDetails$coAuthors |>
        select(lastName, firstName, initials) |>
        distinct(),
      by = c("lastName", "firstName", "initials")
    )

  publicationDetails
}

#' Filter publicationDetails object based on author of interest affiliation match
#'
#' This function is useful in case there are a lot of suprious matches that
#' would be too tedious to manage one by one
#'
#' @param publicationDetails Object generated by ncbi_publicationDetails
#' @param PMIDs Vector of PMIDs to filter
#' @param remove (Default = F). If T the provided PMIDs will be removed instead of
#' @param showWarnings (Default = T). Display warnings if PMIDs don't match
#' filtered out
#'
#' @import dplyr stringr
#'
#' @return Filtered publicationDetails object
#'
#' @export
filter_PMID <- function(
  publicationDetails,
  PMIDs,
  remove = F,
  showWarnings = T
) {
  toKeep = intersect(publicationDetails$articles$PMID, PMIDs)

  if (length(toKeep) < length(PMIDs)) {
    warning(sprintf(
      "The following PMIDs were not found are are ignored: %s",
      paste(setdiff(PMIDs, publicationDetails$articles$PMID), collapse = ",")
    ))
  }

  # Invert in case of removing
  if (remove) {
    toKeep = setdiff(publicationDetails$articles$PMID, toKeep)
  }

  publicationDetails$articles = publicationDetails$articles |>
    filter(PMID %in% toKeep)
  publicationDetails$coAuthors = publicationDetails$coAuthors |>
    filter(PMID %in% toKeep)
  publicationDetails$affiliations = publicationDetails$affiliations |>
    filter(PMID %in% toKeep)
  publicationDetails$meshDescriptors = publicationDetails$meshDescriptors |>
    filter(PMID %in% toKeep)
  publicationDetails$meshQualifiers = publicationDetails$meshQualifiers |>
    filter(PMID %in% toKeep)

  # Only keep author name variations that are in any of the retained articles
  publicationDetails$author = publicationDetails$author |>
    inner_join(
      publicationDetails$coAuthors |>
        select(lastName, firstName, initials) |>
        distinct(),
      by = c("lastName", "firstName", "initials")
    )

  publicationDetails
}

#' Wrapper function for profvis to work in Positron until issue resolved
#' https://github.com/posit-dev/positron/issues/3269
#'
#' @param expr R expression to evaluate with profvis
#' @param folder Default = "local". Folder where to store result files
#'
#' @import profvis
#' @importFrom htmlwidgets saveWidget
#' @importFrom rlang eval_tidy enquo
#'
#' @return Run profvis and open the results in the browser
#'
#' @export
profvisRender <- function(expr, folder = "local") {
  folder = normalizePath(folder)
  temp_file <- tempfile(fileext = ".R")
  writeLines(deparse(substitute(expr)), con = temp_file)

  toTest <- profvis(
    source(temp_file, local = TRUE),
    prof_output = file.path(folder, "proftest.Rprofvis")
  )

  saveWidget(toTest, file.path(folder, "proftest.html"))
  # A URL always has forward slash
  browseURL(normalizePath(file.path(folder, "proftest.html"), winslash = "/"))
}


#' Function to check which temp files can be deleted based on time / size
#'
#'
#' @param folder Temp folder
#' @param hours Number of hours after which files should be removed
#' @param totalSize Max size the temp folder can have in MB. This will mark files
#' for deletion, even if not expired (oldest first) until below limit
#' @param pattern (Optional) File name filter (e.g. extension)
#'
#' @returns list with two elements
#' - fileInfo: data frame with all files and annotation which ones to remove
#' - summary: data frame with summary stats of the files
#'
#' @export
#'
tempFileCheck <- function(folder, hours, totalSize, pattern = NULL) {
  # Get the file info
  fileInfo <- file.info(list.files(
    folder,
    pattern = pattern,
    full.names = T
  ))

  fileInfo <- fileInfo |>
    arrange(desc(mtime)) |>
    mutate(
      delta = difftime(Sys.time(), mtime, units = "hours") |> as.numeric(),
      expired = delta > hours,
      cumSum = cumsum(ifelse(expired, 0, size)),
      exceedCapacity = cumSum / 1024^2 > totalSize,
      toRemove = expired | exceedCapacity,
      path = rownames(fileInfo)
    )

  summary <- fileInfo |>
    group_by(toRemove) |>
    summarise(
      n = n(),
      totalSize = sum(size) / 1024^2,
      nExpired = sum(expired),
      nExceedCapacity = sum(exceedCapacity & !expired)
    )

  return(list(fileInfo = fileInfo, summary = summary))
}

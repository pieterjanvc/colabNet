#' Simplify special characters in text for easier comparisons
#'
#' @param text
#'
#' @importFrom stringi stri_trans_nfd
#' @importFrom stringr str_replace_all
#'
#' @return simplified text
#' @export
#'
simpleText <- function(text) {
  str_replace_all(stri_trans_nfd(tolower(text)), "\\p{Mn}", "") |> str_trim()
}

#' Timestamp
#'
#' @returns Time formatted as %Y-%m-%d %H:%M:%S
timeStamp <- function() {
  format(Sys.time(), format = "%Y-%m-%d %H:%M:%S")
}

#' Check whether to use black or white text on a colour backgound
#'
#' @param colours A vector of colours
#'
#' @return A vector of "black" or "white" for each colour
#' @export
textBW <- function(colours) {
  colours <- col2rgb(colours)

  # Calculate the luminance (0 - 255)
  lum <- apply(colours, 2, function(x) {
    0.2126 * x[1] + 0.7152 * x[2] + 0.0722 * x[3]
  })

  return(ifelse(lum > 127.5, "black", "white"))
}

#' Make a hexadecimal colour lighter (go towards white)
#'
#' @param hex A hexadecimal colour value
#' @param factor How much whiter to make the colour. 0 = no change, 1 = white
#'
#' @return A vector of "black" or "white" for each colour
lightenColour <- function(hex, factor) {
  # Convert hex to RGB
  rgb <- col2rgb(hex) / 255

  # Move each RGB component toward white (1.0)
  lighter_rgb <- rgb + (1 - rgb) * factor

  # Convert back to hex
  rgb_to_hex <- function(x) rgb(x[1], x[2], x[3])
  rgb_to_hex(lighter_rgb)
}

#' Decorate an HTML element with a message
#'
#' @param elementID The ID of the element as set in Shiny
#' @param message (Optional) If set, this message will be shown, if not any
#' existing message for this ID will be removed
#' @param type (Default = "error"). info, error or success (will define the colour)
#' @param where (Default = "afterEnd) Relative position of the message to the
#' ID. Any of "beforeStart", "afterStart", "beforeEnd" or "afterEnd"
#' @param session (Default = getDefaultReactiveDomain()). Shiny session object
#'
#' @importFrom dplyr case_when
#' @importFrom stringr str_detect
#' @importFrom shiny insertUI removeUI getDefaultReactiveDomain
#'
#' @return A dataset that can be used to create a (plotly) Treemap
#' @export
#'
elementMsg <- function(
  elementID,
  message,
  type = "error",
  where = "afterEnd",
  session = getDefaultReactiveDomain()
) {
  # Make sure the tag ID starts with # or .
  tagID <- ifelse(
    str_detect(elementID, "^[.#]"),
    elementID,
    paste0("#", elementID)
  )

  # Remove existing element
  removeUI(paste0(tagID, "_msg"), session = session)

  # Stop if no new message
  if (missing(message)) {
    return()
  }

  # Add / update message
  msg <- tags$div(
    tags$i(
      message,
      style = sprintf(
        "color:%s",
        case_when(
          type == "info" ~ "#2196f3",
          type == "error" ~ "#f44336",
          type == "success" ~ "#4caf50",
          TRUE ~ "#262626"
        )
      )
    ),
    id = paste0(elementID, "_msg")
  )

  insertUI(selector = tagID, where = where, msg, session = session)
}

#' Filter publicationDetails object based on author of interest affiliation match
#'
#' This function is useful in case there are a lot of suprious matches that
#' would be too tedious to manage one by one
#'
#' @param publicationDetails Object generated by ncbi_publicationDetails
#' @param regex Search term (regular expression) to filter affiliations
#'
#' @import dplyr stringr
#'
#' @return Filtered publicationDetails object
#'
#' @export
filter_affiliation <- function(publicationDetails, regex, includeMissing = F) {
  if (is.na(regex) || str_trim(regex) == "") {
    return(publicationDetails)
  }

  # Get PMIDs that have an affilitation match using the regex for author of interest
  toKeep <- publicationDetails$affiliations |>
    filter(str_detect(affiliation, regex)) |>
    left_join(
      publicationDetails$coAuthors |>
        filter(
          lastName %in% publicationDetails$author$lastName,
          firstName %in% publicationDetails$author$firstName,
        ) |>
        select(PMID, authorOrder, tempId),
      by = c("PMID", "authorOrder")
    ) |>
    filter(!is.na(tempId)) |>
    pull(PMID) |>
    unique()

  if (includeMissing) {
    noAffiliations <- setdiff(
      publicationDetails$articles$PMID,
      publicationDetails$affiliations$PMID |> unique()
    )
    toKeep <- c(toKeep, noAffiliations)
  }

  # Filter based on PMIDs retained
  publicationDetails$articles = publicationDetails$articles |>
    filter(PMID %in% toKeep)
  publicationDetails$coAuthors = publicationDetails$coAuthors |>
    filter(PMID %in% toKeep)
  publicationDetails$affiliations = publicationDetails$affiliations |>
    filter(PMID %in% toKeep)
  publicationDetails$meshDescriptors = publicationDetails$meshDescriptors |>
    filter(PMID %in% toKeep)
  publicationDetails$meshQualifiers = publicationDetails$meshQualifiers |>
    filter(PMID %in% toKeep)

  # Only keep author name variations that are in any of the retained articles
  publicationDetails$author = publicationDetails$author |>
    inner_join(
      publicationDetails$coAuthors |>
        select(lastName, firstName, initials) |>
        distinct(),
      by = c("lastName", "firstName", "initials")
    )

  publicationDetails
}

#' Filter publicationDetails object based on author of interest affiliation match
#'
#' This function is useful in case there are a lot of suprious matches that
#' would be too tedious to manage one by one
#'
#' @param publicationDetails Object generated by ncbi_publicationDetails
#' @param PMIDs Vector of PMIDs to filter
#' @param remove (Default = F). If T the provided PMIDs will be removed instead of
#' @param showWarnings (Default = T). Display warnings if PMIDs don't match
#' filtered out
#'
#' @import dplyr stringr
#'
#' @return Filtered publicationDetails object
#'
#' @export
filter_PMID <- function(
  publicationDetails,
  PMIDs,
  remove = F,
  showWarnings = T
) {
  toKeep = intersect(publicationDetails$articles$PMID, PMIDs)

  if (length(toKeep) < length(PMIDs)) {
    warning(sprintf(
      "The following PMIDs were not found are are ignored: %s",
      paste(setdiff(PMIDs, publicationDetails$articles$PMID), collapse = ",")
    ))
  }

  # Invert in case of removing
  if (remove) {
    toKeep = setdiff(publicationDetails$articles$PMID, toKeep)
  }

  publicationDetails$articles = publicationDetails$articles |>
    filter(PMID %in% toKeep)
  publicationDetails$coAuthors = publicationDetails$coAuthors |>
    filter(PMID %in% toKeep)
  publicationDetails$affiliations = publicationDetails$affiliations |>
    filter(PMID %in% toKeep)
  publicationDetails$meshDescriptors = publicationDetails$meshDescriptors |>
    filter(PMID %in% toKeep)
  publicationDetails$meshQualifiers = publicationDetails$meshQualifiers |>
    filter(PMID %in% toKeep)

  # Only keep author name variations that are in any of the retained articles
  publicationDetails$author = publicationDetails$author |>
    inner_join(
      publicationDetails$coAuthors |>
        select(lastName, firstName, initials) |>
        distinct(),
      by = c("lastName", "firstName", "initials")
    )

  publicationDetails
}

#' Wrapper function for profvis to work in Positron until issue resolved
#' https://github.com/posit-dev/positron/issues/3269
#'
#' @param expr R expression to evaluate with profvis
#' @param folder Default = "local". Folder where to store result files
#'
#' @import profvis
#' @importFrom htmlwidgets saveWidget
#' @importFrom rlang eval_tidy enquo
#'
#' @return Run profvis and open the results in the browser
#'
#' @export
profvisRender <- function(expr, folder = "local") {
  folder = normalizePath(folder)
  temp_file <- tempfile(fileext = ".R")
  writeLines(deparse(substitute(expr)), con = temp_file)

  toTest <- profvis(
    source(temp_file, local = TRUE),
    prof_output = file.path(folder, "proftest.Rprofvis")
  )

  saveWidget(toTest, file.path(folder, "proftest.html"))
  # A URL always has forward slash
  browseURL(normalizePath(file.path(folder, "proftest.html"), winslash = "/"))
}

#' Run the colabNet Shiny App
#'
#' @param colabNetDB Path to the ColabNet database (will be created if needed)
#'
#' @import shiny dplyr stringr tidyr purrr visNetwork pool plotly
#' @importFrom shinyjs useShinyjs enable disable
#' @importFrom RSQLite SQLite
#' @importFrom DT DTOutput renderDT datatable dataTableProxy replaceData
#' @importFrom igraph graph_from_data_frame E degree components distances edge_density transitivity
#'
#' @return Start the Shiny app
#'
#' @export
#'
colabNet <- function(colabNetDB, dev = F, dbPath = NULL) {
  normalizePath(dirname(colabNetDB), mustWork = T)
  envInfo = list(
    dev = dev,
    dbPath = dbPath
  )
  sys.source(
    system.file("app.R", package = "colabNet"),
    envir = environment()
  )
  shinyApp(ui, server)
}

#' Recursive algorithm to get sum of all values in a branch of a tree (by node)
#'
#' @param node ID of current node
#' @param parent ID of node's parent
#' @param value Value of the node
#'
#' @import dplyr
#'
#' @return Dataframe containing all info needed to build a plotly treemap
#'
#' @export
nodeSum <- function(node, parent, value) {
  # Coerce to character to avoid indexing issues
  parent <- as.character(parent)
  node <- as.character(node)

  if (length(parent) != length(node) | length(value) != length(node)) {
    stop("Error: 'node', 'parent' and 'value' vectors must be the same length.")
  }

  # Build adjacency list
  children <- split(node, parent)

  # Identify all nodes
  all_nodes <- unique(c(parent, node))

  # Find root (a node that is never a child)
  root <- setdiff(parent, node)
  if (length(root) > 1) {
    stop(
      "Tree must have exactly one root. Found: ",
      paste(root, collapse = ", ")
    )
  } else if (length(root) == 0) {
    root = "0"
  }

  root <- root[1]

  # Map values to nodes
  node_values_raw <- c(setNames(0, "0"), setNames(value, node))

  # Initialize result container
  node_values <- setNames(rep(0, length(all_nodes)), all_nodes)

  # Recursive DFS
  dfs <- function(node) {
    node_value <- node_values_raw[[node]]
    if (is.null(node_value)) {
      node_value <- 0
    }

    total <- node_value

    for (child_node in children[[node]]) {
      total <- total + dfs(child_node)
    }

    node_values[[node]] <<- total
    return(total)
  }

  dfs(root)
  return(data.frame(node = names(node_values), value = unname(node_values)))
}

#' Build a full MeSH tree from papermesh data frame
#'
#' @param papermeshtree Data frame generated by dbPaperMeshTree()
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @import dplyr
#'
#' @return Dataframe containing all info needed to build a plotly treemap
#'
#' @export
treemapData <- function(papermeshtree, colorComparison = T) {
  nAuthors <- n_distinct(papermeshtree$auID[papermeshtree$auID != 0])
  # papermeshtree <<- papermeshtree
  # Merge branches with only one child into a single node
  treemap <- papermeshtree |>
    arrange(treenum) |>
    mutate(
      parentBranchID = ifelse(
        is.na(parentBranchID),
        as.integer(0),
        parentBranchID
      )
    ) |>
    group_by(branchID) |>
    summarise(
      parentBranchID = min(parentBranchID),
      minLvl = min(level),
      meshterm = paste(unique(meshterm), collapse = " -> "),
      treemapVal = sum(treemapVal),
      nPapers = sum(nPapers),
      authors = paste(
        sort(unique(sprintf("%s", name))),
        collapse = "\n"
      ),
      nAuthors = n_distinct(auID[auID != 0]),
      colourCode = ifelse(
        nAuthors == 1,
        auID[auID != 0][1],
        0
      ),
      root = root[1],
      .groups = "drop"
    )

  treemap <- treemap |>
    mutate(
      parentBranchID = ifelse(is.na(parentBranchID), 0, parentBranchID),
      hasChildren = branchID %in% parentBranchID,
      colourCode = colourCode |> factor() |> as.integer()
    )

  meshSum <- nodeSum(
    node = treemap$branchID,
    parent = treemap$parentBranchID,
    value = treemap$nPapers
  ) |>
    transmute(branchID = as.integer(node), meshSum = value)

  treemap <- treemap |> left_join(meshSum, by = "branchID")

  treemap <- bind_rows(
    data.frame(
      branchID = as.integer(0),
      parentBranchID = NA,
      minLvl = 0,
      meshterm = "MeSH Tree",
      treemapVal = 0,
      nPapers = 0,
      colourCode = 1,
      meshSum = sum(treemap |> filter(parentBranchID == 0) |> pull(meshSum)),
      hasChildren = T
    ),
    treemap
  )

  # Calculate the correct colour code working up the tree from the roots
  updateColourCode <- function(treemap) {
    sharedCheck <- treemap |>
      select(branchID, parentBranchID, colourCode, nAuthors, minLvl)

    for (lvl in max(sharedCheck$minLvl):1) {
      lvlInfo <- sharedCheck |>
        filter(minLvl == lvl) |>
        group_by(branchID = parentBranchID) |>
        summarise(
          code = case_when(
            any(colourCode == 1) ~ 1,
            n_distinct(colourCode) > 1 ~ 1,
            TRUE ~ colourCode[1]
          )
        )

      sharedCheck <- sharedCheck |>
        left_join(lvlInfo, by = "branchID") |>
        mutate(
          colourCode = case_when(
            is.na(code) ~ colourCode,
            nAuthors == 0 ~ code,
            colourCode != code ~ 1,
            TRUE ~ colourCode
          )
        ) |>
        select(-code)
    }

    treemap$colourCode = sharedCheck$colourCode
    return(treemap)
  }

  treemap <- updateColourCode(treemap)

  # Set the colour scheme based on how many authors are in the data
  if (nAuthors == 2 & colorComparison) {
    colSel <- c("#7aa64c", "#3398DB", "#F1C40E")

    treemap <- treemap |>
      group_by(colourCode) |>
      mutate(
        colour = treemapColour(
          meshSum,
          minCol = lightenColour(colSel[colourCode[1]], 0.9),
          maxCol = colSel[colourCode[1]]
        )
      ) |>
      ungroup()
  } else {
    treemap$colour <- treemapColour(treemap$meshSum)
  }

  treemap #|> select(-colourCode)
}

#' Generate colours for the treemap based on values
#'
#' @param vals List of values to generate colours for
#' @param minCol Default = "#f2f3f5", Hex colour associated with lowest values
#' in the treemap
#' @param maxCol Default = "#4682B4", Hex colour associated with lowest values
#' in the treemap
#' @param logScale Default = TRUE. Log-scale the values for more gradual colour
#' transitions
#'
#' @return Vector of hexadecimal colour for each value
#'
#' @export
treemapColour <- function(
  vals,
  minCol = "#f2f3f5",
  maxCol = "#4682B4",
  logScale = T
) {
  result <- rep("#FFFFFF", length(vals))
  nas <- is.na(vals)
  vals <- vals[!nas]

  if (logScale) {
    vals <- log(vals + 1)
  }

  val2col <- colorRamp(c(minCol, maxCol))

  if (max(vals) - min(vals) == 0) {
    vals_norm <- rep(0.5, length(vals))
  } else {
    vals_norm <- (vals - min(vals)) / (max(vals) - min(vals))
  }

  rgb_matrix <- val2col(vals_norm)
  vals <- rgb(
    rgb_matrix[, 1],
    rgb_matrix[, 2],
    rgb_matrix[, 3],
    maxColorValue = 255
  )
  result[!nas] = vals
  result
}

#' Generate a TreeMap from a list of author IDs
#'
#' @param auIDs List of authors IDs
#' @param roots (Optional) Vector of single letter representing the tree roots
#' to include. If not specified, all categories are returned
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @return List with two elements
#'  - papermeshtree: Dataframe used to build a TreeMap
#'  - authors: Data frame with default author name and ID
#'
#' @export
papermeshtreeFromAuIDs <- function(auIDs, roots, dbInfo) {
  conn <- dbGetConn(dbInfo)

  papermesh <- dbPaperMesh(auIDs, roots = roots, dbInfo = dbInfo)
  meshtree <- dbMeshTree(papermesh, roots = roots, dbInfo = dbInfo)
  papermeshtree <- paperMeshTree(papermesh, meshtree, dbInfo = dbInfo)

  # Add author names
  au <- tbl(conn, "author") |>
    filter(auID %in% local(unique(papermeshtree$auID))) |>
    select(auID) |>
    left_join(tbl(conn, "authorName") |> filter(default == 1), by = "auID") |>
    collect() |>
    rowwise() |>
    mutate(name = paste(lastName, firstName, sep = ", ")) |>
    select(auID, name)

  papermeshtree <- papermeshtree |>
    left_join(au |> select(auID, name), by = "auID") |>
    mutate(name = ifelse(nPapers == 0, "", name))

  dbDisconnect(conn)

  return(list(papermeshtree = papermeshtree, authors = au))
}

#' Function to calculate values that will balance all rectangles of a Tree map
#' to be equal size
#'
#' @param id Vector of node IDs in the tree
#' @param parent Vector of corresponding parent for each node in id (note that
#' the parent of the root ID should be NA)
#'
#' @import dplyr
#'
#' @return data frame with two columns
#' - id: node ID
#' - balanceVal: value that will balance the box size (only leaves get values)
#'
#' @export
treemapBalance <- function(id, parent) {
  # Remove any duplicated IDs
  remDupl <- !duplicated(id)
  id <- id[remDupl]
  parent <- parent[remDupl]
  # Get the root and leave IDs
  root <- id[is.na(parent)]
  if (length(root) != 1) {
    stop("The must be exactly one root (i.e parent = NA)")
  }
  leaves <- id[!id %in% parent]
  #Function to find the leave values
  leafVal <- function(curID, curVal) {
    if (curID %in% leaves) {
      return(list(id = curID, balanceVal = curVal))
    } else {
      ids <- id[parent == curID]
      ids <- ids[!is.na(ids)]
      results <- lapply(ids, leafVal, curVal = curVal / length(ids))
      return(do.call(Map, c(f = c, results)))
    }
  }

  # Function to calculate the total sum such that all the leaves have integer
  # values (i.e. curVal value for leafVal function).
  # Calculations fail when tree is too large because of integer overflow
  # and thus this function is not being used at the moment but here as backup
  # A value of 1 is used in leafVal generating floating point numbers instead

  # leafSum <- function(curID, curVal) {
  #   if (curID %in% leaves) {
  #     return(curVal)
  #   } else {
  #     ids <- id[parent == curID]
  #     ids <- ids[!is.na(ids)]
  #     results <- sapply(ids, leafSum, curVal = curVal * length(ids))
  #     return(unlist(results))
  #   }
  # }
  #
  # lcm <- function(ints) {
  #   gcd <- function(x, y) {
  #     r <- x %% y
  #     return(ifelse(r, gcd(y, r), y))
  #   }
  #
  #   lcm = 1
  #   for (x in unique(ints)) {
  #     lcm = (lcm * x) %/% gcd(lcm, x)
  #   }
  #
  #   return(lcm)
  # }
  #
  # leafsum <- lcm(leafSum(root, 1))

  leafsum <- 1

  leafvals <- leafVal(root, leafsum) |> as.data.frame()

  rbind(
    data.frame(id = id[!id %in% leafvals$id], balanceVal = 0),
    leafvals
  ) |>
    arrange(id)
}

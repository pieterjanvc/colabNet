#' Recursive algorithm to get sum of all values in a branch of a tree (by node)
#'
#' @param node ID of current node
#' @param parent ID of node's parent
#' @param value Value of the node
#'
#' @import dplyr
#'
#' @return Dataframe containing all info needed to build a plotly treemap
#'
#' @export
nodeSum <- function(node, parent, value) {
  # Coerce to character to avoid indexing issues
  parent <- as.character(parent)
  node <- as.character(node)

  if (length(parent) != length(node) | length(value) != length(node)) {
    stop("Error: 'node', 'parent' and 'value' vectors must be the same length.")
  }

  # Build adjacency list
  children <- split(node, parent)

  # Identify all nodes
  all_nodes <- unique(c(parent, node))

  # Find root (a node that is never a child)
  root <- setdiff(parent, node)
  if (length(root) > 1) {
    stop(
      "Tree must have exactly one root. Found: ",
      paste(root, collapse = ", ")
    )
  } else if (length(root) == 0) {
    root = "0"
  }

  root <- root[1]

  # Map values to nodes
  node_values_raw <- c(setNames(0, "0"), setNames(value, node))

  # Initialize result container
  node_values <- setNames(rep(0, length(all_nodes)), all_nodes)

  # Recursive DFS
  dfs <- function(node) {
    node_value <- node_values_raw[[node]]
    if (is.null(node_value)) {
      node_value <- 0
    }

    total <- node_value

    for (child_node in children[[node]]) {
      total <- total + dfs(child_node)
    }

    node_values[[node]] <<- total
    return(total)
  }

  dfs(root)
  return(data.frame(node = names(node_values), value = unname(node_values)))
}

#' Build a full MeSH tree from papermesh data frame
#'
#' @param papermeshtree Data frame generated by dbPaperMeshTree()
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @import dplyr
#'
#' @return Dataframe containing all info needed to build a plotly treemap
#'
#' @export
treemapData <- function(papermeshtree) {
  # Merge branches with only one child into a single node
  treemap <- papermeshtree |>
    arrange(treenum) |>
    mutate(
      parentBranchID = ifelse(
        is.na(parentBranchID),
        as.integer(0),
        parentBranchID
      )
    ) |>
    group_by(branchID) |>
    summarise(
      parentBranchID = min(parentBranchID),
      meshterm = paste(unique(meshterm), collapse = " -> "),
      treemapVal = sum(treemapVal),
      nPapers = sum(nPapers),
      authors = paste(
        sort(unique(sprintf("%s", name))),
        collapse = "\n"
      ),
      root = root[1],
      .groups = "drop"
    )

  treemap <- treemap |>
    mutate(
      parentBranchID = ifelse(is.na(parentBranchID), 0, parentBranchID),
      hasChildren = branchID %in% parentBranchID
    )

  meshSum <- nodeSum(
    node = treemap$branchID,
    parent = treemap$parentBranchID,
    value = treemap$nPapers
  ) |>
    transmute(branchID = as.integer(node), meshSum = value)

  treemap <- treemap |> left_join(meshSum, by = "branchID")

  bind_rows(
    data.frame(
      branchID = as.integer(0),
      parentBranchID = NA,
      meshterm = "MeSH Tree",
      treemapVal = 0,
      nPapers = 0,
      meshSum = NA,
      hasChildren = T
    ),
    treemap
  )
}

#' Generate colours for the treemap based on values
#'
#' @param vals List of values to generate colours for
#' @param minCol Default = "#f2f3f5", Hex colour associated with lowest values
#' in the treemap
#' @param maxCol Default = "#4682B4", Hex colour associated with lowest values
#' in the treemap
#' @param logScale Default = TRUE. Log-scale the values for more gradual colour
#' transitions
#'
#' @return Vector of hexadecimal colour for each value
#'
#' @export
treemapColour <- function(
  vals,
  minCol = "#f2f3f5",
  maxCol = "#4682B4",
  logScale = T
) {
  result <- rep("#FFFFFF", length(vals))
  nas <- is.na(vals)
  vals <- vals[!nas]

  if (logScale) {
    vals <- log(vals + 1)
  }

  val2col <- colorRamp(c(minCol, maxCol))
  vals_norm <- (vals - min(vals)) / (max(vals) - min(vals))
  rgb_matrix <- val2col(vals_norm)
  vals <- rgb(
    rgb_matrix[, 1],
    rgb_matrix[, 2],
    rgb_matrix[, 3],
    maxColorValue = 255
  )
  result[!nas] = vals
  result
}

#' Generate a TreeMap from a list of author IDs
#'
#' @param auIDs List of authors IDs
#' @param roots (Optional) Vector of single letter representing the tree roots
#' to include. If not specified, all categories are returned
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @return List with two elements
#'  - treemapdata: Dataframe used to build a TreeMap
#'  - authors: Data frame with default author name and ID
#'
#' @export
treemapFromAuIDs <- function(auIDs, roots, dbInfo) {
  conn <- dbGetConn(dbInfo)

  papermesh <- dbPaperMesh(auIDs, roots = roots)
  meshtree <- dbMeshTree(papermesh, roots = roots)
  papermeshtree <- paperMeshTree(papermesh, meshtree)

  # Add author names
  au <- tbl(conn, "author") |>
    filter(auID %in% local(unique(papermeshtree$auID))) |>
    select(auID) |>
    left_join(tbl(conn, "authorName") |> filter(default == 1), by = "auID") |>
    collect() |>
    rowwise() |>
    mutate(name = paste(lastName, firstName, sep = ", ")) |>
    select(auID, name)

  papermeshtree <- papermeshtree |>
    left_join(au |> select(auID, name), by = "auID") |>
    mutate(name = ifelse(nPapers == 0, "", name))

  dbDisconnect(conn)

  return(list(treemapdata = treemapData(papermeshtree), authors = au))
}

#' Generate a treemap that compares two authors
#'
#' @param au1 Author ID for first author
#' @param au2 Author ID for second author
#' @param roots (Optional) Vector of single letter representing the tree roots
#' to include. If not specified, all categories are returned
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @return Dataframe to build TreeMap
#'
#' @export
treeMapComparison <- function(au1, au2, roots, dbInfo) {
  # Get the treemap based on the tho authors only
  treemapdata <- treemapFromAuIDs(c(au1, au2), roots = roots, dbInfo)

  plotData <- treemapdata$treemapdata

  # See which author has which MeSH term
  plotData <- plotData |>
    mutate(
      authors = str_remove(authors, "^\n"), # Because sometimes starts with \n
      colourCode = case_when(
        is.na(authors) ~ 1,
        authors == treemapdata$authors$name[1] ~ 2,
        authors == treemapdata$authors$name[2] ~ 3,
        authors == paste(sort(treemapdata$authors$name), collapse = "\n") ~ 4,
        TRUE ~ 1
      )
    )

  # test <- plotData
  # plotData <- test

  # Work up the tree to see which branches are shared
  toUpdate <- plotData |>
    filter(!hasChildren) |>
    select(branchID = parentBranchID, childCol = colourCode) |>
    group_by(branchID) |>
    mutate(
      childCol = case_when(
        all(2:3 %in% childCol) ~ 4,
        TRUE ~ max(childCol)
      )
    ) |>
    summarise(
      childCol = childCol[1],
      .groups = "drop"
    ) |>
    ungroup() |>
    distinct()

  while (nrow(toUpdate) > 0) {
    plotData <- plotData |>
      left_join(toUpdate, by = "branchID") |>
      mutate(
        colourCode = case_when(
          is.na(childCol) ~ colourCode,
          childCol > colourCode ~ childCol,
          TRUE ~ colourCode
        )
      )

    toUpdate <- plotData |>
      filter(!is.na(childCol)) |>
      select(branchID = parentBranchID, childCol = colourCode) |>
      group_by(branchID) |>
      mutate(
        childCol = case_when(
          all(2:3 %in% childCol) ~ 4,
          TRUE ~ max(childCol, 1)
        )
      ) |>
      summarise(
        childCol = childCol[1],
        .groups = "drop"
      ) |>
      ungroup() |>
      distinct()

    plotData <- plotData |> select(-childCol)
  }

  # Get a colour for each treemap cell based on the author and MeSH term sum
  colSel = c("#CCCCCC", "#3398DB", "#F1C40E", "#7aa64c")

  plotData |>
    group_by(colourCode) |>
    mutate(
      colour = treemapColour(
        meshSum,
        minCol = lightenColour(colSel[colourCode[1]], 0.9),
        maxCol = colSel[colourCode[1]]
      )
    ) |>
    ungroup()
}

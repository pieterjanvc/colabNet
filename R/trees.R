#' Build a MeSH Tree from a list of MeSH IDs
#' Missing nodes will be filled in and the tree will be built until the root
#'
#' @param uids Vector of Mesh uid to buidll the tree
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @import RSQLite
#' @import dplyr
#'
#' @return Dataframe with tree info (mtrID, uid, meshui, treenum)
#' @export
#'
dbTreeFromMesh <- function(uids, dbInfo) {
  conn <- dbGetConn(dbInfo)
  treenums <- tbl(conn, "meshTree") |>
    filter(uid %in% local(unique(uids))) |>
    pull(treenum)

  treenums <- missingTreeNums(treenums, includeOriginal = T, includeRoots = T)

  tbl(conn, "meshTree") |>
    filter(treenum %in% local(treenums)) |>
    left_join(tbl(conn, "meshLink"), by = "uid") |>
    collect() |>
    select(mtrID, uid, meshui, treenum)
}

#' Find and label linear branches (single chain of nodes)
#' These will be labelled with the same branchID, as they can be collapse
#'
#' Meanwhile, a treemapVal for each leaf node will be calculated such that
#' that when rendered as a treemap all cells should roughly be of the same size
#'
#' @param node Vector of node IDs
#' @param parent Vector of parent ID for each node above
#'
#' @return A list with two elements
#'  - branchID: The new branch ID for each node
#'  - treemapVal: The value used to scale a treemap and force all cells to
#'  become roughly the same size
#'
#' @export
branchID <- function(node, parent) {
  if (length(parent) != length(node)) {
    stop("Error: 'node' and 'parent' vectors must be of the same length.")
  }

  # Make sure node IDs are character used as keys
  parent <- as.character(parent)
  node <- as.character(node)

  # Build adjacency list
  children <- split(node, parent)

  # Identify all nodes
  all_nodes <- unique(c(parent, child))

  # Find root (a node that is never a child)
  root <- setdiff(parent, child)
  if (length(root) != 1) {
    stop(
      "Tree must have exactly one root. Found: ",
      paste(root, collapse = ", ")
    )
  }

  # Initialize sets
  branchIDs <- setNames(all_nodes, all_nodes)
  nodeValues <- setNames(rep(0, length(all_nodes)), all_nodes)

  # Recursive DFS function
  dfs <- function(
    node,
    parent = NULL,
    # Estimate a total value such that treemapVals do not become too small
    value = 2^ceiling(log2(length(all_nodes)))
  ) {
    # Branch ID assignment
    if (!is.null(parent) && length(children[[parent]]) == 1) {
      branchIDs[[node]] <<- branchIDs[[parent]]
    }

    # Child lookup
    child_nodes <- if (!is.null(children[[node]])) {
      children[[node]]
    } else {
      character(0)
    }
    num_children <- length(child_nodes)

    if (num_children > 0) {
      nodeValues[[node]] <<- 0
      split_value <- value / num_children
      for (child in child_nodes) {
        dfs(child, node, split_value)
      }
    } else {
      nodeValues[[node]] <<- value
    }
  }

  # Run the recursive algorithm
  dfs(root)

  return(list(branchID = branchIDs, treemapVal = nodeValues))
}

#' Get all of the MeSH terms from papers by a set of authors
#'
#' @param auIDs Vector auIDs
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @import RSQLite
#' @import dplyr
#'
#' @return Dataframe with paper Mesh terms for authors
#'
#' @export
dbPaperMesh <- function(auIDs, dbInfo) {
  # Get all MeshTerms for papers
  tbl(conn, "coauthor") |>
    filter(auID %in% auIDs) |>
    left_join(
      tbl(conn, "mesh_article"),
      by = "arID"
    ) |>
    filter(!is.na(maID)) |>
    left_join(
      tbl(conn, "meshLink"),
      by = "meshui"
    ) |>
    collect()
}

#' Build a full MeSH tree from papermesh data frame
#'
#' @param papermesh Data frame generated by dbPaperMesh()
#' @param dbInfo (optional if dbSetup() has been run)
#'  Path to the ColabNet database or existing connection
#'
#' @import RSQLite
#' @import dplyr
#'
#' @return Dataframe containing the MeSH tree based on papermesh info
#'  This will also contain parentIDs, branchIDs and parentBranchIDs
#'  the tree root name and treemapVals
#'
#' @export
dbMeshTree <- function(papermesh, dbInfo) {
  # Build the basic MeSH tree
  tree <- dbTreeFromMesh(papermesh$uid)

  # Add the MeSH term (actual description)
  tree <- tree |>
    left_join(
      tbl(conn, "meshTerm") |>
        filter(meshui %in% local(unique(tree$meshui))) |>
        group_by(meshui) |>
        # There are many synonyms, pick the first
        filter(row_number() == 1) |>
        collect(),
      by = "meshui"
    )

  # Add a column with the parent ID for each mtrID
  tree <- tree |>
    mutate(
      level = str_count(treenum, "\\.") + 2,
      level = as.integer(ifelse(str_length(treenum) == 1, 1, level)),
      link = str_remove(treenum, "\\.\\d+$"),
      link = case_when(
        link == treenum & str_length(link) == 1 ~ "root",
        link == treenum ~ str_extract(link, "^\\w"),
        TRUE ~ link
      )
    )

  tree <- tree |>
    left_join(
      tree |> select(link = treenum, parent = mtrID),
      by = "link"
    ) |>
    select(-link) |>
    mutate(parent = ifelse(is.na(parent), as.integer(0), parent))

  # Add branch IDs and treemapVals
  branchIDs <- branchID(
    node = tree$mtrID,
    parent = tree$parent
  )

  tree <- tree |>
    left_join(
      data.frame(
        mtrID = as.integer(names(branchIDs$branchID)),
        branchID = as.integer(unname(branchIDs$branchID)),
        treemapVal = unname(branchIDs$treemapVal)
      ),
      by = "mtrID"
    )

  tree <- tree |>
    group_by(branchID) |>
    mutate(link = parent[1]) |>
    ungroup() |>
    left_join(
      tree |> select(link = mtrID, parentBranchID = branchID),
      by = "link"
    ) |>
    mutate(root = str_extract(treenum, "^[^\\.\\s]+")) |>
    select(-link)

  return(
    tree |>
      select(
        mtrID,
        parent,
        treenum,
        branchID,
        parentBranchID,
        root,
        everything()
      )
  )
}

#' Collapse a Mesh Tree based on the branchIDs
#'  All nodes in the same linear branch are merged to reduce unnecessary nesting
#'
#' @param meshtree Data frame generated by dbMeshTree()
#' @param sep. Default = " -> <br>". Separator to use for MeSH terms when
#' collapsing them across nodes
#'
#' @import dplyr
#'
#' @return Dataframe containing the collapsed MeSH tree
#'
#' @export
collapseTree <- function(meshtree, sep = " -> <br>") {
  # Collapse branches into a single node
  tree <- meshtree |>
    group_by(branchID) |>
    summarise(
      parentBranchID = min(parentBranchID),
      leafNodeTreenum = treenum[n()],
      treenum = paste(treenum, collapse = sep),
      meshterm = paste(meshterm, collapse = sep),
      treemapVal = sum(treemapVal),
      root = root[1],
      .groups = "drop"
    )

  # Get the new parent info for the collapsed data and the root
  tree <- tree |>
    left_join(
      tree |>
        select(
          parent = treenum,
          parentBranchID = branchID,
          parentMeshterm = meshterm
        ) |>
        distinct(),
      by = "parentBranchID"
    ) |>
    mutate(
      parentMeshterm = ifelse(
        is.na(parentMeshterm),
        "MeSH Tree",
        parentMeshterm
      )
    )

  return(tree)
}

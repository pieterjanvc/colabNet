#' Title
#'
#' @param articleInfo A data frame representing co-publications with at least
#'  the following columns
#'  - arID
#'  - auID
#'  - lastName
#'  - firstName
#'  - year: year of article publication
#'  - month: month of article publication
#'
#' @returns a list of nodes an edges used to generate graphs / stats
#' @export
#'
copubGraphElements <- function(articleInfo) {
  ## Get the nodes
  nodes <- articleInfo |>
    group_by(id = auID) |>
    summarise(
      label = sprintf("%s %s", lastName[1], firstName[1]),
      year = min(year),
      month = min(month),
      .groups = "drop"
    )
  ## Get the edges
  edgeArticles <- articleInfo |>
    select(auID, arID) |>
    group_by(arID) |>
    filter(n() > 1)

  if (nrow(edgeArticles) == 0) {
    edgeArticles <- data.frame(
      arID = integer(),
      au1 = integer(),
      au2 = integer(),
      edgeID = integer()
    )

    edges <- data.frame(
      id = integer(),
      from = integer(),
      to = integer(),
      weight = integer()
    )
  } else {
    edgeArticles <- edgeArticles |>
      reframe(as.data.frame(combn(auID, 2) |> t())) |>
      rename(au1 = V1, au2 = V2) |>
      group_by(au1, au2) |>
      mutate(edgeID = cur_group_id()) |>
      ungroup()

    edges <- edgeArticles |>
      group_by(id = edgeID, from = au1, to = au2) |>
      summarise(weight = n(), .groups = "drop")
  }

  return(list(nodes = nodes, edges = edges, edgeArticles = edgeArticles))
}

#' Get statistics about the co-publication network
#'
#' @param graphElements A list of craph elements generated by copubGraphElements()
#'
#' @returns A list of statistics describing the graph
#' @export
#'
copubGraphStats <- function(graphElements) {
  auIDs <- graphElements$nodes$id

  # Create an igraph graph object
  g <- graph_from_data_frame(
    d = graphElements$edges |> select(from, to, weight),
    vertices = graphElements$nodes$id,
    directed = F
  )

  statsTable <- data.frame(
    auID = sort(auIDs)
  )

  # Total number of authors
  nAuthors <- length(auIDs)

  # Collaborations per author
  colabs <- rbind(
    graphElements$edges |> select(from, to, weight),
    graphElements$edges |> select(from = to, to = from, weight)
  ) |>
    group_by(auID = from) |>
    summarise(nColabs = sum(weight), .groups = "drop")

  colabs <- rbind(
    colabs,
    data.frame(auID = auIDs[!auIDs %in% colabs$auID], nColabs = 0)
  ) |>
    mutate(
      colabPerc = nColabs / sum(nColabs) * 100
    )

  statsTable <- statsTable |> left_join(colabs, by = "auID")

  # How many others have you published with
  deg <- degree(g)
  deg <- data.frame(auID = as.integer(names(deg)), degree = unname(deg))

  statsTable <- statsTable |> left_join(deg, by = "auID")

  # Check how many sub-graphs there are and who belongs to which
  # Can be used to calculate
  comp <- components(g)
  comp$membership <- data.frame(
    auID = as.integer(names(comp$membership)),
    membership = unname(comp$membership)
  )
  comp$largest_n = max(comp$csize)
  comp$largest_perc = max(comp$csize) / sum(comp$csize) * 100

  statsTable <- statsTable |>
    left_join(comp$membership, by = "auID") |>
    mutate(unconnected = colabPerc == 0)

  # Check how many are not connected to anyone
  unconnected <- sum(comp$csize == 1)

  # Distance matrix between authors (Inf = unconnected)
  dis <- distances(g, algorithm = "unweighted", weights = NA)

  # The graph diameters (longest distance between authors who are connected)
  diam <- max(dis[!is.infinite(dis)])

  # How close is the graph to be being fully connected
  #  i.e. every author shares at least one publication with every other
  dens <- edge_density(g)

  # How often does an author lie on shortest path between two others (i.e. connects them)
  betw <- betweenness(g, directed = F, weights = NA)
  betw <- data.frame(
    auID = as.integer(names(betw)),
    betweenness = unname(betw)
  )
  statsTable <- statsTable |> left_join(betw, by = "auID")

  # How how close an author is to all others in the network (normalised)
  closeNorm <- closeness(g, weights = NA, normalized = T)
  closeNorm <- data.frame(
    auID = as.integer(names(closeNorm)),
    closeness = unname(closeNorm)
  )
  statsTable <- statsTable |> left_join(closeNorm, by = "auID")

  # Global efficiency
  glob <- global_efficiency(g, weights = NA, directed = F)

  # Probability that adjecent nodes (authors are connected)
  # https://transportgeography.org/contents/methods/graph-theory-measures-indices/transitivity-graph/
  trans <- transitivity(g)

  return(list(
    authorStats = statsTable,
    nAuthors = nAuthors,
    components = comp,
    nUnconnected = unconnected,
    distances = dis,
    diameter = diam,
    density = dens,
    globalEffiency = glob,
    transitivity = trans
  ))
}

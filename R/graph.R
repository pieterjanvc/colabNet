#' Create graph elements (nodes, edges) from co-publication data frame
#'
#' @param articleInfo A data frame representing co-publications with at least
#'  the following columns
#'  - arID
#'  - auID
#'  - lastName
#'  - firstName
#'  - year: year of article publication
#'  - month: month of article publication.
#'
#' @import dplyr
#'
#' @returns a list of nodes an edges used to generate graphs / stats
#' @export
#'
copubGraphElements <- function(articleInfo) {
  # Empty dataframe
  if (nrow(articleInfo) == 0) {
    nodes <- data.frame(
      id = integer(),
      label = character(),
      year = integer(),
      month = integer()
    )

    edges <- data.frame(
      id = integer(),
      from = integer(),
      to = integer(),
      weight = integer()
    )

    edgeArticles <- data.frame(
      arID = integer(),
      au1 = integer(),
      au2 = integer(),
      edgeID = integer()
    )
    return(list(nodes = nodes, edges = edges, edgeArticles = edgeArticles))
  }

  ## Get the nodes
  nodes <- articleInfo |>
    group_by(id = auID) |>
    summarise(
      label = sprintf("%s %s", lastName[1], firstName[1]),
      year = min(year),
      month = min(month),
      .groups = "drop"
    )
  ## Get the edges
  edgeArticles <- articleInfo |>
    select(auID, arID) |>
    group_by(arID) |>
    filter(n() > 1)

  if (nrow(edgeArticles) == 0) {
    edgeArticles <- data.frame(
      arID = integer(),
      au1 = integer(),
      au2 = integer(),
      edgeID = integer()
    )

    edges <- data.frame(
      id = integer(),
      from = integer(),
      to = integer(),
      weight = integer()
    )
  } else {
    edgeArticles <- edgeArticles |>
      reframe(as.data.frame(combn(auID, 2) |> t())) |>
      rename(au1 = V1, au2 = V2) |>
      group_by(au1, au2) |>
      mutate(edgeID = cur_group_id()) |>
      ungroup()

    edges <- edgeArticles |>
      group_by(id = edgeID, from = au1, to = au2) |>
      summarise(weight = n(), .groups = "drop")
  }

  return(list(nodes = nodes, edges = edges, edgeArticles = edgeArticles))
}

#' Get statistics about the co-publication network
#'
#' @param graphElements A list of graph elements generated by copubGraphElements()
#'
#' @importFrom igraph graph_from_data_frame components distances betweenness
#' global_efficiency transitivity degree edge_density closeness
#' @importFrom dplyr select left_join mutate across
#'
#' @returns A list of statistics describing the graph
#' @export
#'
copubGraphStats <- function(graphElements) {
  #If empty graph ...
  if (nrow(graphElements$nodes) == 0) {
    return(list(
      authorStats = data.frame(
        auID = integer(),
        nCopubs = integer(),
        colabPerc = numeric(),
        degree = integer(),
        membership = integer(),
        unconnected = logical(),
        betweenness = integer(),
        closeness = numeric()
      ),
      nAuthors = 0,
      components = list(
        membership = data.frame(auID = integer(), membership = integer()),
        csize = 0,
        no = 0,
        largest_n = 0,
        largest_perc = 0
      ),
      nUnconnected = 0,
      distances = matrix(nrow = 0, ncol = 0),
      distance_avg = 0,
      diameter = 0,
      density = 0,
      globalEffiency = 0,
      transitivity = 0
    ))
  }

  auIDs <- graphElements$nodes$id

  # Create an igraph graph object
  g <- graph_from_data_frame(
    d = graphElements$edges |> select(from, to, weight),
    vertices = graphElements$nodes$id,
    directed = F
  )

  statsTable <- data.frame(
    auID = sort(auIDs)
  )

  # Total number of authors
  nAuthors <- length(auIDs)

  # Collaborations per author
  colabs <- rbind(
    graphElements$edges |> select(from, to, weight),
    graphElements$edges |> select(from = to, to = from, weight)
  ) |>
    group_by(auID = from) |>
    summarise(nCopubs = sum(weight), .groups = "drop")

  colabs <- rbind(
    colabs,
    data.frame(auID = auIDs[!auIDs %in% colabs$auID], nCopubs = 0)
  ) |>
    mutate(
      colabPerc = nCopubs / sum(nCopubs) * 100,
      colabPerc = ifelse(is.nan(colabPerc), 0, colabPerc)
    )

  statsTable <- statsTable |> left_join(colabs, by = "auID")

  # How many others have you published with
  deg <- degree(g)
  deg <- data.frame(auID = as.integer(names(deg)), degree = unname(deg))

  statsTable <- statsTable |> left_join(deg, by = "auID")

  # Check how many sub-graphs there are and who belongs to which
  # Can be used to calculate
  comp <- components(g)
  comp$membership <- data.frame(
    auID = as.integer(names(comp$membership)),
    membership = unname(comp$membership)
  )
  comp$largest_n = max(comp$csize)
  comp$largest_perc = max(comp$csize) / sum(comp$csize) * 100

  statsTable <- statsTable |>
    left_join(comp$membership, by = "auID") |>
    mutate(unconnected = colabPerc == 0)

  # Check how many are not connected to anyone
  unconnected <- sum(comp$csize == 1)

  # Distance matrix between authors (Inf = unconnected)
  dis <- distances(g, algorithm = "unweighted", weights = NA)

  # average distance, ignoring unconnected
  dis_avg <- dis[upper.tri(dis)]
  dis_avg <- dis_avg[!is.infinite(dis_avg)]
  dis_avg <- ifelse(length(dis_avg) == 0, 0, mean(dis_avg))

  # The graph diameters (longest distance between authors who are connected)
  diam <- max(dis[!is.infinite(dis)])

  # How close is the graph to be being fully connected
  #  i.e. every author shares at least one publication with every other
  dens <- edge_density(g)

  # How often does an author lie on shortest path between two others (i.e. connects them)
  betw <- betweenness(g, directed = F, weights = NA)
  betw <- data.frame(
    auID = as.integer(names(betw)),
    betweenness = unname(betw)
  )
  statsTable <- statsTable |> left_join(betw, by = "auID")

  # How how close an author is to all others in the network (normalised)
  closeNorm <- closeness(g, weights = NA, normalized = T)
  closeNorm <- data.frame(
    auID = as.integer(names(closeNorm)),
    closeness = unname(closeNorm)
  )
  statsTable <- statsTable |> left_join(closeNorm, by = "auID")

  # Global efficiency
  glob <- global_efficiency(g, weights = NA, directed = F)

  # Probability that adjecent nodes (authors are connected)
  # https://transportgeography.org/contents/methods/graph-theory-measures-indices/transitivity-graph/
  trans <- transitivity(g)
  trans <- ifelse(is.nan(trans), 0, trans)

  statsTable <- statsTable |>
    mutate(
      across(c(nCopubs, degree, membership, betweenness), as.integer),
      across(c(colabPerc, closeness), round, digits = 2)
    )

  return(list(
    authorStats = statsTable,
    nAuthors = nAuthors,
    components = comp,
    nUnconnected = unconnected,
    distances = dis,
    distance_avg = dis_avg,
    diameter = diam,
    density = dens,
    globalEffiency = glob,
    transitivity = trans
  ))
}

#' Calculate the stats trends for a co-publication network over time
#'
#' @param articleInfo Data frame with articleInfo
#' @param windowSize Default = 5. The size of the sliding window to calculate stats
#'
#' @import ggplot2 dplyr tidyr
#'
#' @returns list with two elements
#' - trends: A data frame with the trend stats over time
#' - plot: a ggplot showing the stats over time in facets
#'
#' @export
#'
copubTrendInfo <- function(articleInfo, windowSize = 5) {
  trends <- articleInfo

  # Calculate network stats for each window
  trends <- lapply(min(trends$year):max(trends$year), function(curYear) {
    trends <- trends |>
      filter(between(
        year,
        max(min(trends$year), curYear - windowSize + 1),
        curYear
      ))

    graphElements <- copubGraphElements(trends)
    graphStats <- copubGraphStats(graphElements)

    data.frame(
      year = curYear,
      nAuthors = graphStats$nAuthors,
      nCopubs_median = ifelse(
        length(graphStats$authorStats$nCopubs) == 0,
        0,
        graphStats$authorStats$nCopubs |> median()
      ),
      nColabs_avg = ifelse(
        length(graphStats$authorStats$degree) == 0,
        0,
        graphStats$authorStats$degree |> mean()
      ),
      largestComp = graphStats$components$largest_n,
      unconnected = graphStats$nUnconnected,
      distance_avg = graphStats$distance_avg,
      diameter = graphStats$diameter,
      density = graphStats$density,
      globalEfficiency = graphStats$globalEffiency,
      transitivity = graphStats$transitivity
    )
  }) |>
    bind_rows() |>
    mutate(
      # The first years the sliding window is not complete and the last year
      # is possible having missing data (year not compelte yet)
      fullWindow = ((year - windowSize + 1) >= min(year)) &
        year < max(year) - 1,
      unconnected_perc = unconnected / nAuthors,
      # Diameter and distance need to be adjusted by network size
      diameter_adj = diameter / log(nAuthors),
      distance_avg_adj = distance_avg / log(nAuthors)
    )

  # Convert the data into a long format for plotting
  plotData <- trends |>
    select(
      year,
      fullWindow,
      nCopubs_median,
      nColabs_avg,
      largestComp,
      density,
      globalEfficiency,
      transitivity,
      unconnected,
      diameter_adj,
      distance_avg_adj
    ) |>
    pivot_longer(cols = -c(year, fullWindow))

  # Set the labels for the columns (will become facets)
  facet_labels <- c(
    nCopubs_median = "Median co-publications",
    nColabs_avg = "Average collaborators",
    largestComp = "Size of largest sub-network",
    density = "Density",
    globalEfficiency = "Global efficiency",
    transitivity = "Transitivity",
    unconnected = "Authors with no co-publications",
    diameter_adj = "Size adjusted diameter",
    distance_avg_adj = "Distance adjusted distance"
  )

  # Generate the ggplot
  plot <- ggplot(plotData, aes(x = year, y = value)) +
    geom_line(aes(color = fullWindow, group = 1)) +
    scale_color_manual(values = c("TRUE" = "#4791e5", "FALSE" = "#E59B47")) +
    facet_wrap(
      ~name,
      scales = "free_y",
      labeller = labeller(name = facet_labels)
    ) +
    labs(
      title = sprintf(
        "Co-publication network statistics with %s year sliding window",
        windowSize
      ),
      color = sprintf("Full %i years data", windowSize)
    ) +
    theme_minimal(base_size = 16) +
    theme(
      legend.position = "bottom",
      legend.box = "horizontal"
      # strip.text = element_text(size = rel(1.5))
    )

  return(list(trends = trends, plot = plot))
}

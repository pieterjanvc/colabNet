#' Setup the ColabNet database for the current session
#'
#' @param dbInfo Path to ColabNet Database. If DB does not exist it will be created
#' @param newDBMsg (Default, TRUE) Output a message when a new database was created
#' @param checkSchema (Default, FALSE) Check the schema of an existing datbase against the reference
#' @param returnConn (Default, FALSE) By default this function will save the connection to the database
#' internally to be used by other functions. If set to TRUE, a connection object is returned
#' and needs to be closed manually using dbDisconnect()
#'
#' @import RSQLite
#' @importFrom stringr str_remove
#'
#' @return Nothing (default) or a connection to the ColabNet datbase if returnConn = T
#' @export
#'
dbSetup <- function(dbInfo, newDBMsg = T, checkSchema = F, returnConn = F) {
  # Get the reference schema
  sqlFile <- readLines("database/create_colabNetDB.sql") |>
    paste(collapse = "") |>
    str_remove(";\\s*$")

  if(missing(dbInfo)){
    stop("You need to provide a path for the database")
  }

  if (!file.exists(dbInfo)) {
    tables <- strsplit(sqlFile, ";") |> unlist()
    myConn <- dbConnect(SQLite(), dbInfo)
    q <- sapply(tables, function(sql) {
      q <- dbExecute(myConn, sql)
    })

    if (newDBMsg) message("A new database was created")
  } else if (checkSchema) {
    myConn <- dbConnect(SQLite(), dbInfo)
    # Extract the schema from the database to compare to the reference
    dbSchema <- dbGetQuery(
      myConn, paste('SELECT sql FROM sqlite_master WHERE type IN ("table", "index")',
    ' AND "sql" NOT NULL AND name != \'sqlite_sequence\'')) |>
      unlist() |>
      paste(collapse = ";")

    if (dbSchema != sqlFile) {
      dbDisconnect(myConn)
      stop(
        sprintf("The schema of %s is not valid.\n", dbInfo),
        "- Create a blank database by providing a new path\n",
        "- Edit the schema of the existing database to match the requirements"
      )
    }
  } else {
    myConn <- dbConnect(SQLite(), dbInfo)
  }

  # Save the connection info for the session
  options(dbInfo = dbInfo)

  # Only return the connection if requested
  if (returnConn) {
    return(myConn)
  } else {
    dbDisconnect(myConn)
    invisible()
  }
}

#' Get a ColabNet database connection
#'
#' @param dbInfo (optional if dbSetup() has been run) Path to the ColabNet database
#' or existing connection. If the dbSetup() has been run the assigned database will be used
#' @param checkSchema (Default, TRUE) Check the schema of if dbInfo is explicitly provided.
#'  Ignored when dbSetup() had been used.
#'
#' @import RSQLite
#'
#' @return Connection to the ColabNet database
#' @export
#'
dbGetConn <- function(dbInfo, checkSchema = T) {
  if (missing(dbInfo)) {

    if(is.null(getOption("dbInfo", default = NULL))){
      stop("There is no database set up, please run dbSetup() first")
    }

    conn <- dbConnect(SQLite(), getOption("dbInfo"))
  } else if(inherits(dbInfo, "DBIConnection")){
    conn <- dbInfo
  } else {
    conn <- dbSetup(dbInfo, checkSchema = checkSchema, returnConn = T)
  }

  return(conn)
}

#' Add authors to the database
#'
#' @param authors The coAuthors data frame generated by ncbi_authorPublications
#' @param dbInfo (optional if dbSetup() has been run) Path to the ColabNet database
#'  or existing connection
#'
#' @import RSQLite
#' @import dplyr
#'
#' @return Data frame with new, updated and existing author info
#' @export
#'
dbAddAuthors <- function(authors, dbInfo) {
  conn <- dbGetConn(dbInfo)
  
  if(sqliteIsTransacting(conn)){
    endTransaction = F    
  } else {
    dbBegin(conn)
    endTransaction = T
  }

  # Get all distinct author names, but assume same author is last name and initials are the same
  authors <- authors |>
    select(lastName, firstName, initials, tempId, def = default) |>
    distinct()
  # authors <- authors |>
  #   group_by(x = simpleText(lastName), initials) |>
  #   mutate(tempId = cur_group_id()) |>
  #   ungroup() |>
  #   select(-x)
  authors <- authors |>
    left_join(
      tbl(conn, "authorName"),
      by = c("lastName", "firstName", "initials"), copy = TRUE
    ) |>
    collect()

  # Check which authors already exist in the DB (nothing to do)
  existing <- authors |>
    group_by(tempId) |>
    filter(!is.na(anID)) |>
    ungroup() |>
    mutate(status = "existing")

  # Check authors that are already in the DB, but an alternative version of the name popped up
  updated <- authors |>
    group_by(tempId) |>
    filter(!sum(is.na(anID)) %in% c(0, n())) |>
    ungroup()

  # Add those alternative names to the DB with same author ID
  if (nrow(updated) > 0) {
    updated <- updated |>
      group_by(tempId) |>
      mutate(auID = min(auID, na.rm = T)) |>
      ungroup() |>
      filter(is.na(anID))
    updated <- dbGetQuery(
      conn,
      "INSERT INTO authorName(auID,lastName,firstName,initials,collectiveName)
      VALUES (?,?,?,?,?) RETURNING *",
      params = list(
        updated$auID, updated$lastName, updated$firstName,
        updated$initials, updated$collectiveName
      )
    ) |> mutate(status = "updated")

    q <- dbExecute(conn, "UPDATE author SET modified = ? WHERE auID IN (?)",
      params = list(timeStamp(), paste(unique(updated$auID), collapse = ","))
    )
  }

  # Add authors who are not yet in the DB
  new <- authors |>
    group_by(tempId) |>
    filter(all(is.na(anID))) |>
    ungroup() |>
    select(-auID)

  if (nrow(new) > 0) {
    # Create new author IDs
    auID <- dbGetQuery(conn, "INSERT INTO author(modified) VALUES (?) RETURNING auID",
      params = list(rep(timeStamp(), new$tempId |> n_distinct()))
    )
    auID$tempId <- unique(new$tempId)
    new <- new |> left_join(auID, by = "tempId")

    # Add author names
    new <- dbGetQuery(
      conn,
      "INSERT INTO authorName(auID,\"default\",lastName,firstName,initials,collectiveName)
      VALUES (?,?,?,?,?,?) RETURNING *",
      params = list(new$auID, new$def, new$lastName, new$firstName, new$initials, new$collectiveName)
    ) |> mutate(status = "new")
  }

  if(endTransaction){    
    dbCommit(conn)
    dbDisconnect(conn)
  }  

  return(bind_rows(new, updated, existing) |> select(-tempId))
}

#' Insert MeSH info into the ColabNet database
#'
#' @param values vector of MeSH values to search for
#' @param type The type needs to be 'meshui' (MeSH ui), 'treenum' (tree number) or 'uid' (MeSH Entrez uid)
#' @param dbInfo (optional if dbSetup() has been run) Path to the ColabNet database
#'  or existing connection
#'
#' @import dplyr
#'
#' @return data frame with all uid and meshui inserted into the database (including intermediate tree nodes)
#' @export
#'
dbAddMesh <- function(values, type, dbInfo) {
  conn <- dbGetConn(dbInfo)

  if(sqliteIsTransacting(conn)){
    endTransaction = F    
  } else {
    dbBegin(conn)
    endTransaction = T
  }

  meshInfo <- ncbi_meshInfo(values, type)

  # Check with intermediate tree nodes (treenum) are missing to get to root
  missingNodes <- missingTreeNums(meshInfo$meshTree$treenum)

  # Check DB which missing treenums (intermediate nodes) are already in the DB
  knownTreenums <- tbl(conn, "meshTree") |>
    filter(treenum %in% local(missingNodes)) |>
    pull(treenum)

  # Get info on remaining missing nodes
  missingNodes <- setdiff(missingNodes, knownTreenums)

  # Iteratively add missing nodes
  #  Iteration needed because some IDs have multple treenums
  while (length(missingNodes) > 0) {
    # Seach NCBI and add results
    newNodes <- ncbi_meshInfo(missingNodes, type = "treenum")
    meshInfo$meshTerms <- rbind(meshInfo$meshTerms, newNodes$meshTerms)
    meshInfo$meshTree <- rbind(meshInfo$meshTree, newNodes$meshTree)

    # Again check if there are missing links in the new nodes
    missingNodes <- missingTreeNums(meshInfo$meshTree$treenum)
    knownTreenums <- c(
      knownTreenums,
      tbl(conn, "meshTree") |> filter(treenum %in% local(missingNodes)) |>
        pull(treenum)
    )

    missingNodes <- setdiff(missingNodes, knownTreenums)
  }

  toAdd <- setdiff(meshInfo$meshTree$treenum, knownTreenums)

  if (length(toAdd) > 0) {
    # Only add new tree data
    meshInfo$meshTree <- meshInfo$meshTree |> filter(treenum %in% toAdd)
    meshInfo$meshTerms <- meshInfo$meshTerms |> filter(meshui %in% meshInfo$meshTree$meshui)

    # Add to database
    meshLinks <- meshInfo$meshTree |>
      select(uid, meshui) |>
      distinct()
    existing <- tbl(conn, "meshLink") |>
      filter(uid %in% local(meshLinks$uid)) |>
      select(uid, meshui) |>
      collect()
    meshLinks <- meshLinks |> filter(!uid %in% existing$uid)

    q <- dbExecute(conn, "INSERT INTO meshLink(uid, meshui) VALUES(?,?)",
      params = list(meshLinks$uid, meshLinks$meshui)
    )

    meshTerms <- meshInfo$meshTerms |>
      select(meshui, meshterm) |>
      distinct()
    meshTerms <- meshTerms |> filter(!meshui %in% existing$meshui)
    q <- dbExecute(conn, "INSERT INTO meshTerm(meshui, meshterm) VALUES(?,?)",
      params = list(meshTerms$meshui, meshTerms$meshterm)
    )

    meshTree <- meshInfo$meshTree |>
      select(uid, treenum) |>
      distinct()
    meshTree <- meshTree |> filter(!uid %in% existing$uid)
    q <- dbExecute(conn, "INSERT INTO meshTree(uid, treenum) VALUES(?,?)",
      params = list(meshTree$uid, meshTree$treenum)
    )
  }

  if(endTransaction){
    dbCommit(conn)
    dbDisconnect(conn)
  }

  return(meshLinks)
}

#' Add authors to the database
#'
#' @param authorPublications List of data frames geneated by ncbi_authorPublications()
#' @param dbInfo (optional if dbSetup() has been run) 
#'  Path to the ColabNet database or existing connection
#'
#' @import RSQLite
#' @import dplyr
#'
#' @return Data is inserted into the DB returning a list the author's aritcles (arID and PMID)
#' @export
#'
dbAddAuthorPublications <- function(authorPublications, dbInfo) {
  conn <- dbGetConn(dbInfo)

  if(sqliteIsTransacting(conn)){
    endTransaction = F    
  } else {
    dbBegin(conn)
    endTransaction = T
  }

  ### ADD ARTICLES
  articles <- authorPublications$articles

  # Check which articles are already in the database
  existing <- tbl(conn, "article") |>
    filter(PMID %in% local(articles$PMID)) |>
    select(arID, PMID) |>
    collect() |>
    mutate(status = "existing")
  new <- articles |> filter(!PMID %in% existing$PMID)

  if (nrow(new) > 0) {
    new <- dbGetQuery(
      conn,
      "INSERT INTO article(PMID,title,journal,year,month,day)
      VALUES (?,?,?,?,?,?) RETURNING arID, PMID",
      params = list(new$PMID, new$title, new$journal, new$year, new$month, new$day)
    ) |> mutate(status = "new")
  } else {
    new <- data.frame()
  }

  arInfo <- bind_rows(new, existing)

  # Stop if no new articles were found
  if (all(arInfo$status == "existing")) {
    return(arInfo)
  }

  ### ADD (CO)AUTHOR INFO
  auInfo <- dbAddAuthors(authorPublications$coAuthors, conn)

  # Set authorOfInterest to TRUE to distinguish from co-authors
  auID <- auInfo |> filter(
    lastName %in% authorPublications$author$lastName, 
    initials %in% authorPublications$author$initials) |> pull(auID) |> unique()
  
  if(length(auID) > 1){
    dbRollback(conn)
    dbDisconnect(conn)
    stop("Ambiguous author of interest")
  }
  
  q <- dbExecute(conn, "UPDATE author SET authorOfInterest = 1 WHERE auID = ?",
    params = list(auID)
  )  

  # ADD AFFILIATIONS
  affiliations <- authorPublications$affiliations
  
  existing <- tbl(conn, "affiliation") |>
    filter(affiliation %in% local(unique(affiliations$affiliation))) |>
    collect()
  new <- affiliations |>
    select(affiliation) |>
    distinct() |>
    filter(!affiliation %in% existing$affiliation)
  if (nrow(new) > 0) {
    new <- dbGetQuery(
      conn,
      "INSERT INTO affiliation(affiliation)
      VALUES (?) RETURNING *",
      params = list(new$affiliation)
    )
  }

  afInfo <- bind_rows(new, existing)

  # ADD ARTICLE (CO)AUTHOR INFO AND AFFILIATIONS
  arAuAf <- authorPublications$coAuthors |>
    left_join(auInfo,
      by = c("lastName", "firstName", "initials", "collectiveName"), na_matches = "na"
    ) |>
    left_join(authorPublications$affiliations, by = c("PMID", "authorOrder")) |>
    left_join(afInfo, by = "affiliation") |>
    left_join(arInfo, by = "PMID")
    
  coAuthors <- arAuAf |>
    select(arID, auID, authorOrder) |>
    distinct() 
  q <- dbExecute(conn, "INSERT INTO coAuthor(arID, auID, authorOrder) VALUES(?,?,?)",
    params = list(coAuthors$arID, coAuthors$auID, coAuthors$authorOrder)
  )

  # Sometimes affiliations are not provided so remove the empty ones
  affiliations <- arAuAf |>
    select(arID, auID, afID) |>
    distinct() |> filter(!is.na(afID))
  q <- dbExecute(conn, "INSERT INTO author_affiliation(arID, auID, afID) VALUES(?,?,?)",
    params = list(affiliations$arID, affiliations$auID, affiliations$afID)
  )

  # ADD MESH INFO
  # First make sure the MeSH tree is complete for any new terms
  meshDescriptors <- authorPublications$meshDescriptors |>
    left_join(arInfo, by = "PMID") |>
    filter(status == "new")

  if (nrow(meshDescriptors) > 0) {
    meshui <- unique(meshDescriptors$DescriptorUI)

    if (length(meshui) > 0) {
      result <- dbAddMesh(meshui, "meshui", dbInfo = conn)
    }

    # Insert meshUI from papers
    meshArticle <- meshDescriptors |>
      select(arID, PMID, DescriptorUI, DescriptorMajor) |>
      distinct() |>
      mutate(DescriptorMajor = ifelse(DescriptorMajor == "Y", 1, 0))

    q <- dbExecute(conn, "INSERT INTO mesh_article(arID, meshui, descriptorMajor) VALUES(?,?,?)",
      params = list(meshArticle$arID, meshArticle$DescriptorUI, meshArticle$DescriptorMajor)
    )
  }

  if(endTransaction){
    dbCommit(conn)
    dbDisconnect(conn)
  }  

  return(arInfo)
}
